<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="ExDoc v0.32.2">
    <meta name="project" content="elli v3.3.0">


    <title>Elli - Overview — elli v3.3.0</title>
    <link rel="stylesheet" href="dist/html-erlang-EBZIIHAS.css" />


    <script src="dist/handlebars.runtime-NWIB6V2M.js"></script>
    <script src="dist/handlebars.templates-K7URE6B4.js"></script>
    <script src="dist/sidebar_items-FF1D4582.js"></script>
    <script src="docs_config.js"></script>
    <script async src="dist/html-BHYOTRCH.js"></script>


  </head>
  <body data-type="extras" class="page-extra">
    <script>

      try {
        var settings = JSON.parse(localStorage.getItem('ex_doc:settings') || '{}');

        if (settings.theme === 'dark' ||
           ((settings.theme === 'system' || settings.theme == null) &&
             window.matchMedia('(prefers-color-scheme: dark)').matches)
           ) {
          document.body.classList.add('dark')
        }
      } catch (error) { }
    </script>

<div class="body-wrapper">

<button id="sidebar-menu" class="sidebar-button sidebar-toggle" aria-label="toggle sidebar" aria-controls="sidebar">
  <i class="ri-menu-line ri-lg" title="Collapse/expand sidebar"></i>
</button>

<nav id="sidebar" class="sidebar">

  <div class="sidebar-header">
    <div class="sidebar-projectInfo">

      <div>
        <a href="readme.html" class="sidebar-projectName" translate="no">
elli
        </a>
        <div class="sidebar-projectVersion" translate="no">
          v3.3.0
        </div>
      </div>
    </div>
    <ul id="sidebar-listNav" class="sidebar-listNav" role="tablist">
      <li>
        <button id="extras-list-tab-button" role="tab" data-type="extras" aria-controls="extras-tab-panel" aria-selected="true" tabindex="0">
Pages
        </button>
      </li>

        <li>
          <button id="modules-list-tab-button" role="tab" data-type="modules" aria-controls="modules-tab-panel" aria-selected="false" tabindex="-1">
            Modules
          </button>
        </li>


    </ul>
  </div>

  <div id="extras-tab-panel" class="sidebar-tabpanel" role="tabpanel" aria-labelledby="extras-list-tab-button">
    <ul id="extras-full-list" class="full-list"></ul>
  </div>

    <div id="modules-tab-panel" class="sidebar-tabpanel" role="tabpanel" aria-labelledby="modules-list-tab-button" hidden>
      <ul id="modules-full-list" class="full-list"></ul>
    </div>


</nav>

<main class="content">
  <output role="status" id="toast"></output>

  <div id="content" class="content-inner">
    <div class="top-search">
      <div class="search-settings">
        <form class="search-bar" action="search.html">
          <label class="search-label">
            <span class="sr-only">Search documentation of elli</span>
            <input name="q" type="text" class="search-input" placeholder="Press / to search" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" />
          </label>
          <button type="submit" class="search-button" aria-label="Submit Search">
            <i class="ri-search-2-line ri-lg" aria-hidden="true" title="Submit search"></i>
          </button>
          <button type="button" tabindex="-1" class="search-close-button" aria-hidden="true">
            <i class="ri-close-line ri-lg" title="Cancel search"></i>
          </button>
        </form>
        <div class="autocomplete">
        </div>
        <button class="icon-settings display-settings">
          <i class="ri-settings-3-line"></i>
          <span class="sr-only">Settings</span>
        </button>
      </div>
    </div>

<div id="top-content">
  <h1>

      <a href="https://github.com/elli-lib/elli/blob/v3.3.0/OVERVIEW.md#L1" title="View Source" class="icon-action" rel="help">
        <i class="ri-code-s-slash-line" aria-hidden="true"></i>
        <span class="sr-only">View Source</span>
      </a>


    <span>Elli - Overview</span>
  </h1>

<p>Copyright (c) 2012-2016 Knut Nesheim, 2016-2018 elli-lib team</p><p><strong>Version:</strong> 3.3.0</p><p><strong>Authors:</strong> Knut Nesheim, elli-lib team.</p><p>Erlang web server for HTTP APIs</p><h2 id="features" class="section-heading">
  <a href="#features" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Features</span>
</h2>
<p>Here's the features Elli <em>does</em> have:</p><ul><li><p><a href="https://github.com/rack/rack" title="">Rack</a>-style request-response. Your handler function gets a
 complete request and returns a complete response. There's no
 messaging, no receiving data directly from the socket, no writing
 responses directly to the socket. It's a very simple and
 straightforward API. Have a look at <a href="elli_example_callback.html"><code class="inline">elli_example_callback</code></a>
for examples.</p></li><li><p>Middlewares allow you to add useful features like compression,
encoding, stats, but only have it used when needed. No features you
don't use on the critical path.</p></li><li><p>Short-circuiting of responses using exceptions, allows you to use
 &quot;assertions&quot; that return for example 403 permission
 denied. <code class="inline">is_allowed(Req) orelse throw({403, [], &lt;&lt;&quot;Permission denied&quot;&gt;&gt;})</code>.</p></li><li><p>Every client connection gets its own process, isolating the failure
of a request from another. For the duration of the connection, only
one process is involved, resulting in very robust and efficient
code.</p></li><li><p>Binaries everywhere for strings.</p></li><li><p>Instrumentation inside the core of the webserver, triggering user
 callbacks. For example when a request completes, the user callback
 gets the <code class="inline">request_complete</code> event which contains timings of all the
different parts of handling a request. There's also events for
clients unexpectedly closing a connection, crashes in the user
callback, etc.</p></li><li><p>Keep alive, using one Erlang process per connection only active
when there is a request from the client. Number of connections is
only limited by RAM and CPU.</p></li><li><p>Chunked transfer in responses for real-time push to clients</p></li><li><p>Basic pipelining. HTTP verbs that does not have side-effects(<code class="inline">GET</code>
 and <code class="inline">HEAD</code>) can be pipelined, ie. a client supporting pipelining
can send multiple requests down the line and expect the responses
to appear in the same order as requests. Elli processes the
requests one at a time in order, future work could make it possible
to process them in parallel.</p></li><li><p>SSL using built-in Erlang/OTP ssl, nice for low volume admin
interfaces, etc. For high volume, you should probably go with
nginx, stunnel or ELB if you're on AWS.</p></li><li><p>Implement your own connection handling, for WebSockets, streaming
 uploads, etc. See <a href="elli_example_callback_handover.html"><code class="inline">elli_example_callback_handover</code></a>.</p></li></ul><h2 id="extensions" class="section-heading">
  <a href="#extensions" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Extensions</span>
</h2>
<p>Here's some ready-to-use extensions for Elli.</p><ul><li><a href="https://github.com/elli-lib/elli_access_log">elli_access_log</a>:
Access log</li><li><a href="https://github.com/elli-lib/elli_basicauth">elli_basicauth</a>:
Basic auth</li><li><a href="https://github.com/elli-lib/elli_chatterbox">elli_chatterbox</a>:
HTTP/2 support</li><li><a href="https://github.com/elli-lib/elli_cloudfront">elli_cloudfront</a>:
CloudFront signed URLs</li><li><a href="https://github.com/elli-lib/elli_cookie">elli_cookie</a>:
Cookies</li><li><a href="https://github.com/elli-lib/elli_date">elli_date</a>:
&quot;Date&quot; header</li><li><a href="https://github.com/elli-lib/elli_fileserve">elli_fileserve</a>:
Static content</li><li><a href="https://github.com/elli-lib/elli_prometheus">elli_prometheus</a>:
Prometheus</li><li><a href="https://github.com/elli-lib/elli_stats">elli_stats</a>:
Real-time statistics dashboard</li><li><a href="https://github.com/elli-lib/elli_websocket">elli_websockets</a>:
WebSockets</li><li><a href="https://github.com/elli-lib/elli_xpblfe">elli_xpblfe</a>:
X-Powered-By LFE</li></ul><p>You can also find a more complete list at <a href="https://github.com/elli-lib">https://github.com/elli-lib</a>.</p><h2 id="about" class="section-heading">
  <a href="#about" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">About</span>
</h2>
<p>From operating and debugging high-volume, low-latency apps we have
gained some valuable insight into what we want from a webserver. We
want simplicity, robustness, performance, ease of debugging,
visibility into strange client behaviour, really good instrumentation
and good tests. We are willing to sacrifice almost everything, even
basic features to achieve this.</p><p>With this in mind we looked at the big names in the Erlang
community: <a href="https://github.com/klacke/yaws" title="">Yaws</a>, <a href="https://github.com/mochi/mochiweb" title="">Mochiweb</a>, <a href="https://github.com/ostinelli/misultin" title="">Misultin</a> and <a href="https://github.com/ninenines/cowboy" title="">Cowboy</a>. We
found <a href="https://github.com/mochi/mochiweb" title="">Mochiweb</a> to be the best match. However, we also wanted to
see if we could take the architecture of <a href="https://github.com/mochi/mochiweb" title="">Mochiweb</a> and improve on
it. Elli takes the acceptor-turns-into-request-handler idea found
in <a href="https://github.com/mochi/mochiweb" title="">Mochiweb</a>, the binaries-only idea from <a href="https://github.com/ninenines/cowboy" title="">Cowboy</a> and the
request-response idea from <a href="https://www.python.org/dev/peps/pep-3333/" title="">WSGI</a>/<a href="https://github.com/rack/rack" title="">Rack</a> (with chunked transfer
being an exception).</p><p>On top of this we built a handler that allows us to write HTTP
middleware modules to add practical features, like compression of
responses, HTTP access log with timings, a real-time statistics
dashboard and chaining multiple request handlers.</p><h2 id="aren-t-there-enough-webservers-in-the-erlang-community-already" class="section-heading">
  <a href="#aren-t-there-enough-webservers-in-the-erlang-community-already" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Aren't there enough webservers in the Erlang community already?</span>
</h2>
<p>There are a few very mature and robust projects with steady
development, one recently ceased development and one new kid on the
block with lots of interest. As Elli is not a general purpose
webserver, but more of a specialized tool, we believe it has a very
different target audience and would not attract effort or users away
from the big names.</p><h2 id="why-another-webserver-isn-t-this-just-the-nih-syndrome" class="section-heading">
  <a href="#why-another-webserver-isn-t-this-just-the-nih-syndrome" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Why another webserver? Isn't this just the NIH syndrome?</span>
</h2>
<p><a href="https://github.com/klacke/yaws" title="">Yaws</a>, <a href="https://github.com/mochi/mochiweb" title="">Mochiweb</a>, <a href="https://github.com/ostinelli/misultin" title="">Misultin</a>, and <a href="https://github.com/ninenines/cowboy" title="">Cowboy</a> are great
projects, hardened over time and full of very useful features for web
development. If you value developer productivity, <a href="https://github.com/klacke/yaws" title="">Yaws</a> is an
excellent choice. If you want a fast and lightweight
server, <a href="https://github.com/mochi/mochiweb" title="">Mochiweb</a> and <a href="https://github.com/ninenines/cowboy" title="">Cowboy</a> are excellent choices.</p><p>Having used and studied all of these projects, we believed that if we
merged some of the existing ideas and added some ideas from other
communities, we could create a core that was better for our use cases.</p><p>It started out as an experiment to see if it is at all possible to
significantly improve and it turns out that for our particular use
cases, there is enough improvement to warrant a new project.</p><h2 id="what-makes-elli-different" class="section-heading">
  <a href="#what-makes-elli-different" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">What makes Elli different?</span>
</h2>
<p>Elli has a very simple architecture. It avoids using more processes
and messages than absolutely necessary. It uses binaries for
strings. The request-response programming model allows middlewares to
do much heavy lifting, so the core can stay very simple. It has been
instrumented so as a user you can understand where time is spent. When
things go wrong, like the client closed the connection before you
could send a response, you are notified about these things so you can
better understand your client behaviour.</p><h2 id="performance" class="section-heading">
  <a href="#performance" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Performance</span>
</h2>
<p>&quot;Hello World!&quot; micro-benchmarks are really useful when measuring the
performance of the webserver itself, but the numbers usually do more
harm than good when released. I encourage you to run your own
benchmarks, on your own hardware. Mark Nottingham has some
<a href="http://www.mnot.net/blog/2011/05/18/http_benchmark_rules">very good pointers</a>
about benchmarking HTTP servers.</p>
</div>

<div class="bottom-actions" id="bottom-actions">
  <div class="bottom-actions-item">

      <a href="readme.html" class="bottom-actions-button" rel="prev">
        <span class="subheader">
          ← Previous Page
        </span>
        <span class="title">
Elli - Erlang web server for HTTP APIs
        </span>
      </a>

  </div>
  <div class="bottom-actions-item">

      <a href="changelog.html" class="bottom-actions-button" rel="next">
        <span class="subheader">
          Next Page →
        </span>
        <span class="title">
CHANGELOG
        </span>
      </a>

  </div>
</div>
    <footer class="footer">
      <p>

          <span class="line">
            <a href="https://hex.pm/packages/elli/3.3.0" class="footer-hex-package">Hex Package</a>

            <a href="https://preview.hex.pm/preview/elli/3.3.0">Hex Preview</a>

              (<a href="https://preview.hex.pm/preview/elli/3.3.0/show/OVERVIEW.md">current file</a>)

          </span>

        <span class="line">
          <button class="a-main footer-button display-quick-switch" title="Search HexDocs packages">
            Search HexDocs
          </button>

            <a href="elli.epub" title="ePub version">
              Download ePub version
            </a>

        </span>
      </p>

      <p class="built-using">
        Built using
        <a href="https://github.com/elixir-lang/ex_doc" title="ExDoc" target="_blank" rel="help noopener" translate="no">ExDoc</a> (v0.32.2) for the

          <a href="https://erlang.org" title="Erlang" target="_blank" translate="no">Erlang programming language</a>

      </p>

    </footer>
  </div>
</main>
</div>


  </body>
</html>
