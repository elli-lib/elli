searchData={"items":[{"type":"module","title":"elli","doc":"Elli acceptor manager This gen_server owns the listen socket and manages the processes accepting on that socket. When a process waiting for accept gets a request, it notifies this gen_server so we can start up another acceptor.","ref":"elli.html"},{"type":"function","title":"elli.get_acceptors/1","doc":null,"ref":"elli.html#get_acceptors/1"},{"type":"function","title":"elli.get_open_reqs/1","doc":null,"ref":"elli.html#get_open_reqs/1"},{"type":"function","title":"elli.get_open_reqs/2","doc":null,"ref":"elli.html#get_open_reqs/2"},{"type":"function","title":"elli.set_callback/3","doc":null,"ref":"elli.html#set_callback/3"},{"type":"function","title":"elli.start_link/0","doc":"Create an Elli server process as part of a supervision tree, using the default configuration. The same as start_link({callback, elli_example_callback}, {callback_args, []}) .","ref":"elli.html#start_link/0"},{"type":"function","title":"elli.start_link/1","doc":null,"ref":"elli.html#start_link/1"},{"type":"function","title":"elli.stop/1","doc":"Stop Server .","ref":"elli.html#stop/1"},{"type":"type","title":"elli.body/0","doc":"A binary or iolist.","ref":"elli.html#t:body/0"},{"type":"type","title":"elli.header/0","doc":null,"ref":"elli.html#t:header/0"},{"type":"type","title":"elli.headers/0","doc":null,"ref":"elli.html#t:headers/0"},{"type":"type","title":"elli.http_method/0","doc":"An uppercase atom representing a known HTTP verb or a binary for other verbs.","ref":"elli.html#t:http_method/0"},{"type":"type","title":"elli.req/0","doc":null,"ref":"elli.html#t:req/0"},{"type":"type","title":"elli.response_code/0","doc":null,"ref":"elli.html#t:response_code/0"},{"type":"opaque","title":"elli.state/0","doc":"Internal state.","ref":"elli.html#t:state/0"},{"type":"module","title":"elli_example_callback","doc":"Elli example callback Your callback needs to implement two functions, handle/2 and handle_event/3 . For every request, Elli will call your handle function with the request. When an event happens, like Elli completed a request, there was a parsing error or your handler threw an error, handle_event/3 is called.","ref":"elli_example_callback.html"},{"type":"function","title":"elli_example_callback.chunk_loop/1","doc":"Send 10 separate chunks to the client. The same as chunk_loop(Ref, 10)","ref":"elli_example_callback.html#chunk_loop/1"},{"type":"function","title":"elli_example_callback.handle/2","doc":"Handle a Req uest. Delegate to our handler function. See handle/3","ref":"elli_example_callback.html#handle/2"},{"type":"function","title":"elli_example_callback.handle_event/3","doc":"Handle Elli events, fired throughout processing a request. elli_startup is sent when Elli is starting up. If you are implementing a middleware, you can use it to spawn processes, create ETS tables or start supervised processes in a supervisor tree. request_complete fires *after* Elli has sent the response to the client. Timings contains timestamps (native units) of events like when the connection was accepted, when headers/body parsing finished, when the user callback returns, response sent, etc. Sizes contains response sizes like response headers size, response body or file size. This allows you to collect performance statistics for monitoring your app. request_throw , request_error and request_exit events are sent if the user callback code throws an exception, has an error or exits. After triggering this event, a generated response is sent to the user. invalid_return is sent if the user callback code returns a term not understood by elli, see elli_http:execute_callback/1 . After triggering this event, a generated response is sent to the user. chunk_complete fires when a chunked response is completely sent. It's identical to the request_complete event, except instead of the response body you get the atom client or server depending on who closed the connection. Sizes will have the key chunks , which is the total size of all chunks plus encoding overhead. request_closed is sent if the client closes the connection when Elli is waiting for the next request on a keep alive connection. request_timeout is sent if the client times out when Elli is waiting for the request. request_parse_error fires if the request is invalid and cannot be parsed by [ erlang:decode_packet/3 ][decode_packet/3] or it contains a path Elli cannot parse or does not support. [decode_packet/3]: http://erlang.org/doc/man/erlang.html#decode_packet-3 client_closed can be sent from multiple parts of the request handling. It's sent when the client closes the connection or if for any reason the socket is closed unexpectedly. The Where atom tells you in which part of the request processing the closed socket was detected: receiving_headers , receiving_body or before_response . client_timeout can as with client_closed be sent from multiple parts of the request handling. If Elli tries to receive data from the client socket and does not receive anything within a timeout, this event fires and the socket is closed. bad_request is sent when Elli detects a request is not well formatted or does not conform to the configured limits. Currently the Reason variable can be {too_many_headers, Headers} or {body_size, ContentLength} . file_error is sent when the user wants to return a file as a response, but for some reason it cannot be opened.","ref":"elli_example_callback.html#handle_event/3"},{"type":"module","title":"elli_example_callback_handover","doc":null,"ref":"elli_example_callback_handover.html"},{"type":"function","title":"elli_example_callback_handover.handle/2","doc":null,"ref":"elli_example_callback_handover.html#handle/2"},{"type":"function","title":"elli_example_callback_handover.init/2","doc":"Return {ok, handover} if Req 's path is /hello/world , otherwise ignore .","ref":"elli_example_callback_handover.html#init/2"},{"type":"behaviour","title":"elli_handler","doc":null,"ref":"elli_handler.html"},{"type":"callback","title":"elli_handler.handle/2","doc":null,"ref":"elli_handler.html#c:handle/2"},{"type":"callback","title":"elli_handler.handle_event/3","doc":null,"ref":"elli_handler.html#c:handle_event/3"},{"type":"callback","title":"elli_handler.init/2","doc":null,"ref":"elli_handler.html#c:init/2"},{"type":"callback","title":"elli_handler.postprocess/3","doc":null,"ref":"elli_handler.html#c:postprocess/3"},{"type":"callback","title":"elli_handler.preprocess/2","doc":null,"ref":"elli_handler.html#c:preprocess/2"},{"type":"type","title":"elli_handler.callback/0","doc":"A tuple of a t:callback_mod() and t:callback_args() .","ref":"elli_handler.html#t:callback/0"},{"type":"type","title":"elli_handler.callback_args/0","doc":"Arguments to pass to a t:callback_mod()","ref":"elli_handler.html#t:callback_args/0"},{"type":"type","title":"elli_handler.callback_mod/0","doc":"A callback module.","ref":"elli_handler.html#t:callback_mod/0"},{"type":"type","title":"elli_handler.event/0","doc":"Fired throughout processing a request. See elli_example_callback:handle_event/3 for descriptions.","ref":"elli_handler.html#t:event/0"},{"type":"type","title":"elli_handler.result/0","doc":null,"ref":"elli_handler.html#t:result/0"},{"type":"module","title":"elli_http","doc":"Elli HTTP request implementation An elli_http process blocks in elli_tcp:accept/3 until a client connects. It then handles requests on that connection until it's closed either by the client timing out or explicitly by the user.","ref":"elli_http.html"},{"type":"function","title":"elli_http.accept/4","doc":"Accept on the socket until a client connects. Handle the request, then loop if we're using keep alive or chunked transfer. If elli_tcp:accept/3 doesn't return a socket within a configurable timeout, loop to allow code upgrades of this module.","ref":"elli_http.html#accept/4"},{"type":"function","title":"elli_http.chunk_loop/1","doc":null,"ref":"elli_http.html#chunk_loop/1"},{"type":"function","title":"elli_http.close_or_keepalive/2","doc":"Return the preferred session handling setting to close or keep the current session alive based on the presence of a header or the standard default based on the version of HTTP of the request.","ref":"elli_http.html#close_or_keepalive/2"},{"type":"function","title":"elli_http.handle_request/4","doc":"Handle a HTTP request that will possibly come on the socket. Returns the appropriate connection token and any buffer containing (parts of) the next request.","ref":"elli_http.html#handle_request/4"},{"type":"function","title":"elli_http.keepalive_loop/3","doc":"Handle multiple requests on the same connection, i.e. &quot;keep alive&quot; .","ref":"elli_http.html#keepalive_loop/3"},{"type":"function","title":"elli_http.keepalive_loop/5","doc":null,"ref":"elli_http.html#keepalive_loop/5"},{"type":"function","title":"elli_http.mk_req/8","doc":null,"ref":"elli_http.html#mk_req/8"},{"type":"function","title":"elli_http.mk_req/11","doc":null,"ref":"elli_http.html#mk_req/11"},{"type":"function","title":"elli_http.parse_path/1","doc":null,"ref":"elli_http.html#parse_path/1"},{"type":"function","title":"elli_http.send_file/5","doc":"Send a HTTP response to the client where the body is the contents of the given file. Assumes correctly set response code and headers.","ref":"elli_http.html#send_file/5"},{"type":"function","title":"elli_http.send_response/4","doc":"Generate a HTTP response and send it to the client.","ref":"elli_http.html#send_response/4"},{"type":"function","title":"elli_http.split_args/1","doc":"Split the URL arguments into a proplist. Lifted from cowboy_http:x_www_form_urlencoded/2.","ref":"elli_http.html#split_args/1"},{"type":"function","title":"elli_http.start_link/4","doc":null,"ref":"elli_http.html#start_link/4"},{"type":"type","title":"elli_http.version/0","doc":"HTTP version as a tuple, i.e. {0, 9} | {1, 0} | {1, 1} .","ref":"elli_http.html#t:version/0"},{"type":"module","title":"elli_middleware","doc":"HTTP request processing middleware. This module offers both pre-processing of requests and post-processing of responses. It can also be used to allow multiple handlers, where the first handler to return a response short-circuits the request. It is implemented as a plain elli handler. Usage: Config = [ { mods , [ { elli_example_middleware , [ ] } , { elli_middleware_compress , [ ] } , { elli_example_callback , [ ] } ] } ] , elli : start_link ( [ %% ..., { callback , elli_middleware } , { callback_args , Config } ] ) . The configured modules may implement the elli behaviour, in which case all the callbacks will be used as normal. If link handle/2 returns ignore , elli will continue on to the next callback in the list. Pre-processing and post-processing is implemented in preprocess/2 and postprocess/3 . preprocess/2 is called for each middleware in the order specified, while postprocess/3 is called in the reverse order.","ref":"elli_middleware.html"},{"type":"module","title":"elli_middleware_compress","doc":"Response compression as Elli middleware.","ref":"elli_middleware_compress.html"},{"type":"function","title":"elli_middleware_compress.postprocess/3","doc":"Postprocess all requests and compress bodies larger than compress_byte_size ( 1024 by default).","ref":"elli_middleware_compress.html#postprocess/3"},{"type":"module","title":"elli_request","doc":null,"ref":"elli_request.html"},{"type":"function","title":"elli_request.async_send_chunk/2","doc":"Send a chunk asynchronously.","ref":"elli_request.html#async_send_chunk/2"},{"type":"function","title":"elli_request.body/1","doc":"Return the body .","ref":"elli_request.html#body/1"},{"type":"function","title":"elli_request.body_qs/1","doc":"Parse application/x-www-form-urlencoded body into a proplist.","ref":"elli_request.html#body_qs/1"},{"type":"function","title":"elli_request.chunk_ref/1","doc":"Return a reference that can be used to send chunks to the client. If the protocol does not support it, return {error, not_supported} .","ref":"elli_request.html#chunk_ref/1"},{"type":"function","title":"elli_request.close_chunk/1","doc":"Explicitly close the chunked connection. Return {error, closed} if the client already closed the connection. The same as send_chunk(Ref, close)","ref":"elli_request.html#close_chunk/1"},{"type":"function","title":"elli_request.get_arg/2","doc":null,"ref":"elli_request.html#get_arg/2"},{"type":"function","title":"elli_request.get_arg/3","doc":null,"ref":"elli_request.html#get_arg/3"},{"type":"function","title":"elli_request.get_arg_decoded/2","doc":null,"ref":"elli_request.html#get_arg_decoded/2"},{"type":"function","title":"elli_request.get_arg_decoded/3","doc":null,"ref":"elli_request.html#get_arg_decoded/3"},{"type":"function","title":"elli_request.get_args/1","doc":"Return a proplist of keys and values of the original query string. Both keys and values in the returned proplists will be binaries or the atom true in case no value was supplied for the query value.","ref":"elli_request.html#get_args/1"},{"type":"function","title":"elli_request.get_args_decoded/1","doc":null,"ref":"elli_request.html#get_args_decoded/1"},{"type":"function","title":"elli_request.get_header/2","doc":null,"ref":"elli_request.html#get_header/2"},{"type":"function","title":"elli_request.get_header/3","doc":null,"ref":"elli_request.html#get_header/3"},{"type":"function","title":"elli_request.get_range/1","doc":"Parse the Range header from the request. The result is either a [http_range()] or the atom parse_error . Use elli_util:normalize_range/2 to get a validated, normalized range.","ref":"elli_request.html#get_range/1"},{"type":"function","title":"elli_request.headers/1","doc":"Return the headers that have had string:casefold/1 run on each key.","ref":"elli_request.html#headers/1"},{"type":"function","title":"elli_request.host/1","doc":"Return the host .","ref":"elli_request.html#host/1"},{"type":"function","title":"elli_request.is_request/1","doc":null,"ref":"elli_request.html#is_request/1"},{"type":"function","title":"elli_request.method/1","doc":"Return the method .","ref":"elli_request.html#method/1"},{"type":"function","title":"elli_request.original_headers/1","doc":"Return the original headers .","ref":"elli_request.html#original_headers/1"},{"type":"function","title":"elli_request.path/1","doc":"Return path split into binary parts.","ref":"elli_request.html#path/1"},{"type":"function","title":"elli_request.peer/1","doc":null,"ref":"elli_request.html#peer/1"},{"type":"function","title":"elli_request.port/1","doc":"Return the port .","ref":"elli_request.html#port/1"},{"type":"function","title":"elli_request.post_arg/2","doc":null,"ref":"elli_request.html#post_arg/2"},{"type":"function","title":"elli_request.post_arg/3","doc":null,"ref":"elli_request.html#post_arg/3"},{"type":"function","title":"elli_request.post_arg_decoded/2","doc":null,"ref":"elli_request.html#post_arg_decoded/2"},{"type":"function","title":"elli_request.post_arg_decoded/3","doc":null,"ref":"elli_request.html#post_arg_decoded/3"},{"type":"function","title":"elli_request.post_args/1","doc":null,"ref":"elli_request.html#post_args/1"},{"type":"function","title":"elli_request.post_args_decoded/1","doc":null,"ref":"elli_request.html#post_args_decoded/1"},{"type":"function","title":"elli_request.query_str/1","doc":"Calculate the query string associated with a given Request as a binary.","ref":"elli_request.html#query_str/1"},{"type":"function","title":"elli_request.raw_path/1","doc":"Return the raw_path , i.e. not split or parsed for query params.","ref":"elli_request.html#raw_path/1"},{"type":"function","title":"elli_request.scheme/1","doc":"Return the scheme .","ref":"elli_request.html#scheme/1"},{"type":"function","title":"elli_request.send_chunk/2","doc":"Send a chunk synchronously. If the referenced process is dead, return early with {error, closed} , instead of timing out.","ref":"elli_request.html#send_chunk/2"},{"type":"function","title":"elli_request.to_proplist/1","doc":"Serialize the Req uest record to a proplist. Useful for logging.","ref":"elli_request.html#to_proplist/1"},{"type":"function","title":"elli_request.uri_decode/1","doc":null,"ref":"elli_request.html#uri_decode/1"},{"type":"type","title":"elli_request.http_range/0","doc":null,"ref":"elli_request.html#t:http_range/0"},{"type":"module","title":"elli_sendfile","doc":null,"ref":"elli_sendfile.html"},{"type":"function","title":"elli_sendfile.sendfile/5","doc":"Send part of a file on a socket. Basically, see file:sendfile/5 but for ssl (i.e. not raw OS sockets). Originally from https://github.com/ninenines/ranch/pull/41/files","ref":"elli_sendfile.html#sendfile/5"},{"type":"type","title":"elli_sendfile.sendfile_opts/0","doc":null,"ref":"elli_sendfile.html#t:sendfile_opts/0"},{"type":"module","title":"elli_tcp","doc":"Wrapper for plain and SSL sockets. Based on mochiweb_socket.erl .","ref":"elli_tcp.html"},{"type":"function","title":"elli_tcp.accept/3","doc":null,"ref":"elli_tcp.html#accept/3"},{"type":"function","title":"elli_tcp.close/1","doc":null,"ref":"elli_tcp.html#close/1"},{"type":"function","title":"elli_tcp.listen/3","doc":null,"ref":"elli_tcp.html#listen/3"},{"type":"function","title":"elli_tcp.peername/1","doc":null,"ref":"elli_tcp.html#peername/1"},{"type":"function","title":"elli_tcp.recv/3","doc":null,"ref":"elli_tcp.html#recv/3"},{"type":"function","title":"elli_tcp.send/2","doc":null,"ref":"elli_tcp.html#send/2"},{"type":"function","title":"elli_tcp.sendfile/5","doc":null,"ref":"elli_tcp.html#sendfile/5"},{"type":"function","title":"elli_tcp.setopts/2","doc":null,"ref":"elli_tcp.html#setopts/2"},{"type":"type","title":"elli_tcp.socket/0","doc":null,"ref":"elli_tcp.html#t:socket/0"},{"type":"module","title":"elli_test","doc":"Helper for calling your Elli callback in unit tests. Only the callback specified is actually run. Elli's response handling is not used, so the headers will for example not include a content length and the return format is not standardized. The unit tests below test elli_example_callback .","ref":"elli_test.html"},{"type":"function","title":"elli_test.call/5","doc":null,"ref":"elli_test.html#call/5"},{"type":"module","title":"elli_util","doc":null,"ref":"elli_util.html"},{"type":"function","title":"elli_util.encode_range/2","doc":"Encode Range to a Content-Range value.","ref":"elli_util.html#encode_range/2"},{"type":"function","title":"elli_util.file_size/1","doc":"Get the size, in bytes, of the file.","ref":"elli_util.html#file_size/1"},{"type":"function","title":"elli_util.normalize_range/2","doc":"If a valid byte-range, or byte-range-set of size 1, is supplied, returns a normalized range in the format {Offset, Length} . Returns undefined when an empty byte-range-set is supplied and the atom invalid_range in all other cases.","ref":"elli_util.html#normalize_range/2"},{"type":"type","title":"elli_util.range/0","doc":null,"ref":"elli_util.html#t:range/0"},{"type":"extras","title":"Elli - Erlang web server for HTTP APIs","doc":"# Elli - Erlang web server for HTTP APIs\n\n[![Hex.pm](https://img.shields.io/hexpm/v/elli.svg)](https://hex.pm/packages/elli)\n[![Documentation](https://img.shields.io/badge/docs-edown-green.svg)](doc/README.md)\n[![Erlang](https://img.shields.io/badge/erlang-%E2%89%A520.0-red.svg)](http://www.erlang.org/downloads)\n![Common Test](https://github.com/elli-lib/elli/workflows/Common%20Test/badge.svg)\n[![Coverage Status](https://coveralls.io/repos/github/elli-lib/elli/badge.svg?branch=develop)](https://coveralls.io/github/elli-lib/elli?branch=develop)\n[![MIT License](https://img.shields.io/badge/license-MIT-blue.svg)](LICENSE)\n\nElli is a webserver you can run inside your Erlang application to\nexpose an HTTP API. It is aimed exclusively at building\nhigh-throughput, low-latency HTTP APIs. If robustness and performance\nis more important to you than general purpose features, then Elli might be\nfor you. If you find yourself digging into the implementation of a\nwebserver, then Elli might be for you. If you're building web services,\nnot web sites, then Elli might be for you.\n\nElli requires OTP 20.0 or newer.","ref":"readme.html"},{"type":"extras","title":"Installation - Elli - Erlang web server for HTTP APIs","doc":"Add `elli` to your application as a dependency to your\n[`rebar.config`](https://www.rebar3.org/docs/configuration):\n\n```erlang\n{deps, [\n  {elli, \"3.3.0\"}\n]}.\n```\n\nAfterwards, to compile it, you can run:\n\n```console\nrebar3 compile\n```","ref":"readme.html#installation"},{"type":"extras","title":"Usage - Elli - Erlang web server for HTTP APIs","doc":"To boot Elli inside an Erlang shell, run:\n\n```console\nrebar3 shell\n```\n\n```erlang\n%% starting elli\n1> {ok, Pid} = elli:start_link([{callback, elli_example_callback}, {port, 3000}]).\n```","ref":"readme.html#usage"},{"type":"extras","title":"Examples - Elli - Erlang web server for HTTP APIs","doc":"","ref":"readme.html#examples"},{"type":"extras","title":"Callback Module - Elli - Erlang web server for HTTP APIs","doc":"The best source to learn how to write a callback module\nis [`elli_example_callback`](elli_example_callback.html).\nThere are also a bunch\nof examples used in the tests as well as descriptions of all the events.\n\nA minimal callback module looks something like this:\n\n```erlang\n-module(elli_minimal_callback).\n-behaviour(elli_handler).\n\n-include_lib(\"elli/include/elli.hrl\").\n\n-export([handle/2, handle_event/3]).\n\nhandle(Req, _Args) ->\n    %% Delegate to our handler function\n    Method = Req#req.method,\n    Path = elli_request:path(Req),\n    handle(Method, Path, Req).\n\nhandle('GET' = _Method, [<<\"hello\">>, <<\"world\">>] = _Path, _Req) ->\n    %% Reply with a normal response. `ok' can be used instead of `200'\n    %% to signal success.\n    StatusCode = ok,\n    Headers = [],\n    Body = <<\"Hello World!\">>,\n    {StatusCode, Headers, Body};\n\nhandle(_Method, _Path, _Req) ->\n    {404, [], <<\"Not Found\">>}.\n\n%% @doc Handle request events: request completed, exception\n%% thrown, client timeout, etc. Must return `ok'.\nhandle_event(_Event, _Data, _Args) ->\n    ok.\n```","ref":"readme.html#callback-module"},{"type":"extras","title":"Supervisor ChildSpec - Elli - Erlang web server for HTTP APIs","doc":"To add `elli` to a supervisor you can use the following example and adapt it to\nyour needs.\n\n```erlang\n-module(elli_minimal_sup).\n-behaviour(supervisor).\n\n-export([start_link/0, init/1]).\n\nstart_link() ->\n    SupName = {local, ?MODULE},\n    Module = ?MODULE,\n    Args = [],\n    supervisor:start_link(SupName, Module, Args).\n\ninit([] = _Args) ->\n    ElliOpts = [\n        {callback, elli_minimal_callback},\n        {port, 3000}\n    ],\n    ElliSpec = {\n        _Id = elli_minimal_http,\n        _Start = {elli, start_link, [ElliOpts]},\n        _Restart = permanent,\n        _Shutdown = 5000,\n        _Worker = worker,\n        _Modules = [elli]},\n\n    {ok, {{_Strategy = one_for_one, _Intensity = 5, _Period = 10}, [ElliSpec]} }.\n```","ref":"readme.html#supervisor-childspec"},{"type":"extras","title":"Further reading - Elli - Erlang web server for HTTP APIs","doc":"For more information about the features and design philosophy of Elli check\nout the [`overview`](overview.html).","ref":"readme.html#further-reading"},{"type":"extras","title":"License - Elli - Erlang web server for HTTP APIs","doc":"Elli is licensed under [The MIT License](LICENSE).","ref":"readme.html#license"},{"type":"extras","title":"Elli - Overview","doc":"# Elli - Overview\n\nCopyright (c) 2012-2016 Knut Nesheim, 2016-2018 elli-lib team\n\n__Version:__ 3.3.0\n\n__Authors:__ Knut Nesheim, elli-lib team.\n\nErlang web server for HTTP APIs","ref":"overview.html"},{"type":"extras","title":"Features - Elli - Overview","doc":"Here's the features Elli _does_ have:\n\n* [Rack][]-style request-response. Your handler function gets a\n   complete request and returns a complete response. There's no\n   messaging, no receiving data directly from the socket, no writing\n   responses directly to the socket. It's a very simple and\n   straightforward API. Have a look at [`elli_example_callback`](elli_example_callback.html)\nfor examples.\n\n* Middlewares allow you to add useful features like compression,\nencoding, stats, but only have it used when needed. No features you\ndon't use on the critical path.\n\n* Short-circuiting of responses using exceptions, allows you to use\n   \"assertions\" that return for example 403 permission\n   denied. `is_allowed(Req) orelse throw({403, [], <<\"Permission\n   denied\">>})`.\n\n* Every client connection gets its own process, isolating the failure\nof a request from another. For the duration of the connection, only\none process is involved, resulting in very robust and efficient\ncode.\n\n* Binaries everywhere for strings.\n\n* Instrumentation inside the core of the webserver, triggering user\n   callbacks. For example when a request completes, the user callback\n   gets the `request_complete` event which contains timings of all the\ndifferent parts of handling a request. There's also events for\nclients unexpectedly closing a connection, crashes in the user\ncallback, etc.\n\n* Keep alive, using one Erlang process per connection only active\nwhen there is a request from the client. Number of connections is\nonly limited by RAM and CPU.\n\n* Chunked transfer in responses for real-time push to clients\n\n* Basic pipelining. HTTP verbs that does not have side-effects(`GET`\n   and `HEAD`) can be pipelined, ie. a client supporting pipelining\ncan send multiple requests down the line and expect the responses\nto appear in the same order as requests. Elli processes the\nrequests one at a time in order, future work could make it possible\nto process them in parallel.\n\n* SSL using built-in Erlang/OTP ssl, nice for low volume admin\ninterfaces, etc. For high volume, you should probably go with\nnginx, stunnel or ELB if you're on AWS.\n\n* Implement your own connection handling, for WebSockets, streaming\n   uploads, etc. See [`elli_example_callback_handover`](elli_example_callback_handover.html).","ref":"overview.html#features"},{"type":"extras","title":"Extensions - Elli - Overview","doc":"Here's some ready-to-use extensions for Elli.\n\n* [elli_access_log](https://github.com/elli-lib/elli_access_log):\nAccess log\n* [elli_basicauth](https://github.com/elli-lib/elli_basicauth):\nBasic auth\n* [elli_chatterbox](https://github.com/elli-lib/elli_chatterbox):\nHTTP/2 support\n* [elli_cloudfront](https://github.com/elli-lib/elli_cloudfront):\nCloudFront signed URLs\n* [elli_cookie](https://github.com/elli-lib/elli_cookie):\nCookies\n* [elli_date](https://github.com/elli-lib/elli_date):\n\"Date\" header\n* [elli_fileserve](https://github.com/elli-lib/elli_fileserve):\nStatic content\n* [elli_prometheus](https://github.com/elli-lib/elli_prometheus):\nPrometheus\n* [elli_stats](https://github.com/elli-lib/elli_stats):\nReal-time statistics dashboard\n* [elli_websockets](https://github.com/elli-lib/elli_websocket):\nWebSockets\n* [elli_xpblfe](https://github.com/elli-lib/elli_xpblfe):\nX-Powered-By LFE\n\nYou can also find a more complete list at  .","ref":"overview.html#extensions"},{"type":"extras","title":"About - Elli - Overview","doc":"From operating and debugging high-volume, low-latency apps we have\ngained some valuable insight into what we want from a webserver. We\nwant simplicity, robustness, performance, ease of debugging,\nvisibility into strange client behaviour, really good instrumentation\nand good tests. We are willing to sacrifice almost everything, even\nbasic features to achieve this.\n\nWith this in mind we looked at the big names in the Erlang\ncommunity: [Yaws][], [Mochiweb][], [Misultin][] and [Cowboy][]. We\nfound [Mochiweb][] to be the best match. However, we also wanted to\nsee if we could take the architecture of [Mochiweb][] and improve on\nit. Elli takes the acceptor-turns-into-request-handler idea found\nin [Mochiweb][], the binaries-only idea from [Cowboy][] and the\nrequest-response idea from [WSGI][]/[Rack][] (with chunked transfer\nbeing an exception).\n\nOn top of this we built a handler that allows us to write HTTP\nmiddleware modules to add practical features, like compression of\nresponses, HTTP access log with timings, a real-time statistics\ndashboard and chaining multiple request handlers.","ref":"overview.html#about"},{"type":"extras","title":"Aren't there enough webservers in the Erlang community already? - Elli - Overview","doc":"There are a few very mature and robust projects with steady\ndevelopment, one recently ceased development and one new kid on the\nblock with lots of interest. As Elli is not a general purpose\nwebserver, but more of a specialized tool, we believe it has a very\ndifferent target audience and would not attract effort or users away\nfrom the big names.","ref":"overview.html#aren-t-there-enough-webservers-in-the-erlang-community-already"},{"type":"extras","title":"Why another webserver? Isn't this just the NIH syndrome? - Elli - Overview","doc":"[Yaws][], [Mochiweb][], [Misultin][], and [Cowboy][] are great\nprojects, hardened over time and full of very useful features for web\ndevelopment. If you value developer productivity, [Yaws][] is an\nexcellent choice. If you want a fast and lightweight\nserver, [Mochiweb][] and [Cowboy][] are excellent choices.\n\nHaving used and studied all of these projects, we believed that if we\nmerged some of the existing ideas and added some ideas from other\ncommunities, we could create a core that was better for our use cases.\n\nIt started out as an experiment to see if it is at all possible to\nsignificantly improve and it turns out that for our particular use\ncases, there is enough improvement to warrant a new project.","ref":"overview.html#why-another-webserver-isn-t-this-just-the-nih-syndrome"},{"type":"extras","title":"What makes Elli different? - Elli - Overview","doc":"Elli has a very simple architecture. It avoids using more processes\nand messages than absolutely necessary. It uses binaries for\nstrings. The request-response programming model allows middlewares to\ndo much heavy lifting, so the core can stay very simple. It has been\ninstrumented so as a user you can understand where time is spent. When\nthings go wrong, like the client closed the connection before you\ncould send a response, you are notified about these things so you can\nbetter understand your client behaviour.","ref":"overview.html#what-makes-elli-different"},{"type":"extras","title":"Performance - Elli - Overview","doc":"\"Hello World!\" micro-benchmarks are really useful when measuring the\nperformance of the webserver itself, but the numbers usually do more\nharm than good when released. I encourage you to run your own\nbenchmarks, on your own hardware. Mark Nottingham has some\n[very good pointers](http://www.mnot.net/blog/2011/05/18/http_benchmark_rules)\nabout benchmarking HTTP servers.\n\n[Yaws]: https://github.com/klacke/yaws\n[Mochiweb]: https://github.com/mochi/mochiweb\n[Misultin]: https://github.com/ostinelli/misultin\n[Cowboy]: https://github.com/ninenines/cowboy\n[WSGI]: https://www.python.org/dev/peps/pep-3333/\n[Rack]: https://github.com/rack/rack","ref":"overview.html#performance"},{"type":"extras","title":"CHANGELOG","doc":"# CHANGELOG","ref":"changelog.html"},{"type":"extras","title":"pre-v4.0.0 - CHANGELOG","doc":"* Headers are now properly treated as case-insensitive\n* Original headers that have not had `string:casefold/1` run on each header\nname are still available in the request through `elli_request:original_headers`","ref":"changelog.html#pre-v4-0-0"},{"type":"extras","title":"v3.3.0 - CHANGELOG","doc":"* Do not use x-forwarded-for for peer #75\n* Handle arguments with no value in (post|get)_arg_decoded #82\n* Fix compile-time warnings on missing record info. from aleppo #81","ref":"changelog.html#v3-3-0"},{"type":"extras","title":"v3.2.0 - CHANGELOG","doc":"* Quell warnings on OTP-21:  \n\n* Generate HTML docs:  \n\n* Add OTP-21 to Travis build matrix:  \n\n* Remove unnecessary `stacktrace_compat` dependency:  \n\n* Export `elli_request:uri_decode/1` and improve performance:  \n\n* Update Travis config:  \n\n* Drop support for OTP-16:  \n\n* Prefer `OTP_RELEASE` over `rebar_erl_vsn` plugin:  \n\n* Remove old `maintainers` metadata:","ref":"changelog.html#v3-2-0"},{"type":"extras","title":"v3.1.0 - CHANGELOG","doc":"* Update docs:  \n\n* Logging and stacktrace OTP-21 support:  \n\n* Include req_body size in sizes list:  \n\n* Update CHANGELOG.md for 3.0.0:","ref":"changelog.html#v3-1-0"},{"type":"extras","title":"v3.0.0 - CHANGELOG","doc":"* `scheme`, `host`, and `port` added to the `#req{}` record. Corresponding\n helper functions added to the `elli_request` module.","ref":"changelog.html#v3-0-0"},{"type":"extras","title":"v2.1.2 - CHANGELOG","doc":"* Update dependencies and re-enable linting\n\n* Increase test coverage\n\n* Declare optional callbacks to elli_handler\n\n* Add TLS sendfile implementation by James Fish (from Andrew Thompson)\n\n* Use hackney instead of httpc in tests, due to httpc bug","ref":"changelog.html#v2-1-2"},{"type":"extras","title":"v2.0.2 - CHANGELOG","doc":"* Adapt [knutin/elli#108](https://github.com/knutin/elli/pull/108) by Michael Zazaian\n\n* Incomplete request regression fix by Evan Vigil-McClanahan\n\n* Handle binary URIs on OTP >=20\n\n* Bespoke uri_decode/1 to obviate inets dependency by Christoffer Vikström","ref":"changelog.html#v2-0-2"},{"type":"extras","title":"v2.0.1 - CHANGELOG","doc":"* Miscellaneous tooling, test, and type spec tweaks\n\n* Helper functions to reduce redundancy\n\n* Request start timing fix","ref":"changelog.html#v2-0-1"},{"type":"extras","title":"v2.0.0 - CHANGELOG","doc":"* Code and documentation cleanup\n\n* Instrumentation facilities\n\n* RFC 2616 section 8.2.3 implementation by Martin Karlsson\n\n* Send 500 and close connection if file operations fail","ref":"changelog.html#v2-0-0"},{"type":"extras","title":"v1.0.5 - CHANGELOG","doc":"* Optimization of SSL accept by Tristan Sloughter\n\n* Dependency cleanup by Adam Lindberg","ref":"changelog.html#v1-0-5"},{"type":"extras","title":"v1.0.4 - CHANGELOG","doc":"* OTP 18.0 compatibility, contributed by Florian Odronitz.","ref":"changelog.html#v1-0-4"},{"type":"extras","title":"v1.0.3 - CHANGELOG","doc":"* Various internal cleanup fixes from Andreas Stenius (github.com/kaos)","ref":"changelog.html#v1-0-3"},{"type":"extras","title":"v1.0.2 - CHANGELOG","doc":"* Added `elli_request:get_args_decoded/1` which returns the list of\n query args decoded each time it's called.","ref":"changelog.html#v1-0-2"},{"type":"extras","title":"v1.0.1 - CHANGELOG","doc":"* Fix bug in SSL acceptor pool where due to failed handshakes, Elli\n runs out of acceptors. Thanks to Stefan Grundmann.\n\n* In case a handler (or middleware) returns a response Elli does not\n understand, Elli will now respond with a 500 error. Thanks to\n Johannes Huning.\n\n* Added `elli_request:get_arg_decoded/2,3` which HTTP URI decodes the\n value passed in the request. Thanks to Mariano Valles.","ref":"changelog.html#v1-0-1"},{"type":"extras","title":"v1.0 - CHANGELOG","doc":"* SSL using built-in ssl from Erlang/OTP. Thanks to Maas-Maarten Zeeman.\n\n* \"Handover\" a socket to user code, making it possible to implement\n WebSockets( ).\n\n* Type fixes from Ingo Struck and Andreas Hasselberg.","ref":"changelog.html#v1-0"},{"type":"extras","title":"v0.4.1 - CHANGELOG","doc":"* Fix from Christian Lundgren for browsers that include spaces in the\n value of the Content-Length header.","ref":"changelog.html#v0-4-1"},{"type":"extras","title":"v0.4 - CHANGELOG","doc":"* Added support for sending ranges of a file with sendfile by\n returning `{Code, Headers, {file, Filename, {Offset, Length}}}`. If\n no offset and length is specified, the entire file is sent. The\n user must provide an appropriate \"Content-Length\" and\n \"Content-Range\" header, see the example in\n `elli_example_callback.erl`\n ( ).\n Thanks Vincent Siliakus (zambal).","ref":"changelog.html#v0-4"},{"type":"extras","title":"v0.3 - CHANGELOG","doc":"* Breaking change: Timeouts used in the HTTP protocol are now\n configurable. To implement this, changing a record and some\n callbacks was necessary. To upgrade, a restart of Elli is needed.\n\n* Elli now supports pipelining of any type of request. Some proxies\n or special clients (like ibrowse) will pipeline requests to reduce\n latency.\n\n* If there are no more file descriptors, Elli will shut down. This\n mimics the behaviour found in Yaws.\n\n* Chunked transfer responses will now exit the Elli process when the\n client closes the connection. Sending a synchronous chunk will\n return `{error, closed}` if client has closed the connection and\n the `chunk_complete` event is sent to your callback including which\n end closed the connection.","ref":"changelog.html#v0-3"},{"type":"extras","title":"v0.2.0 - CHANGELOG","doc":"* Breaking change: moved elli_access_log into a separate repository\n at github.com/wooga/elli_access_log. Thanks martinrehfeld.","ref":"changelog.html#v0-2-0"},{"type":"extras","title":"v0.1.3 - CHANGELOG","doc":"* Added elli_test which makes it easy to write unit tests for your\n callbacks. Thanks anha0825.\n\n* Added sendfile support. Thanks chrisavl.","ref":"changelog.html#v0-1-3"},{"type":"extras","title":"v0.1.2 - CHANGELOG","doc":"* Added option to specify listen IP address. Thanks hukl.","ref":"changelog.html#v0-1-2"},{"type":"extras","title":"v0.1.1 - CHANGELOG","doc":"* Don't look up the peer ip address on every request anymore, do it\n on demand using elli_request:peer/1.","ref":"changelog.html#v0-1-1"},{"type":"extras","title":"v0.1 - CHANGELOG","doc":"* Initial release.","ref":"changelog.html#v0-1"},{"type":"extras","title":"LICENSE","doc":"The MIT License\n\nCopyright (c) 2012-2016 Knut Nesheim\nCopyright (c) 2016-2018 elli-lib team\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.","ref":"license.html"}],"content_type":"text/plain","producer":{"name":"ex_doc","version":[48,46,51,50,46,50]}}